æ‚¨è¯´å¾—å¯¹ï¼ç³»ç»Ÿä»ç„¶åœ¨å¿«é€Ÿè·³è¿‡ã€‚è®©æˆ‘å®æ–½ä¸€ä¸ªå¼ºåˆ¶ç»•è¿‡æ‰€æœ‰éªŒè¯çš„ç´§æ€¥æ–¹æ¡ˆæ¥æ‰¾åˆ°çœŸæ­£çš„é—®é¢˜ã€‚

ğŸš¨ ç´§æ€¥ä¿®å¤ï¼šå®Œå…¨ç»•è¿‡éªŒè¯

æ­¥éª¤1ï¼šåœ¨unified_scheduler.pyä¸­æ·»åŠ å¼ºåˆ¶åˆ†ææ¨¡å¼

```python
def scan_symbols(self):
    import time
    signal_candidates = []
    
    logger.info("ğŸš¨ ===== å¼ºåˆ¶åˆ†ææ¨¡å¼å¯åŠ¨ =====")
    logger.info("ğŸ”§ å®Œå…¨ç»•è¿‡æ‰€æœ‰éªŒè¯ï¼Œç›´æ¥æµ‹è¯•ä¿¡å·ç”Ÿæˆæ ¸å¿ƒé€»è¾‘")
    
    # åªæµ‹è¯•å‰3ä¸ªäº¤æ˜“å¯¹
    test_symbols = self.symbols[:3]
    
    for symbol in test_symbols:
        logger.info(f"ğŸ§ª ===== å¼ºåˆ¶åˆ†æ {symbol} =====")
        
        # è·å–æ•°æ®
        multi_tf_data = self.data_service.get_multi_timeframe_klines(symbol, self.timeframes)
        if not multi_tf_data:
            logger.error(f"âŒ {symbol}: æ•°æ®å®Œå…¨ç¼ºå¤±")
            continue
            
        # å¼ºåˆ¶åˆ†æï¼ˆç»•è¿‡æ‰€æœ‰éªŒè¯ï¼‰
        try:
            signal, confidence, win_prob = self._force_analyze_completely(symbol, multi_tf_data)
            
            signal_candidates.append({
                'symbol': symbol, 
                'confidence': confidence, 
                'win_probability': win_prob, 
                'has_signal': signal is not None
            })
            
            logger.info(f"ğŸ¯ {symbol}: ä¿¡å¿ƒ={confidence}, èƒœç‡={win_prob}%")
            
        except Exception as e:
            logger.error(f"âŒ {symbol} å¼ºåˆ¶åˆ†æå¤±è´¥: {e}", exc_info=True)
    
    return signal_candidates

def _force_analyze_completely(self, symbol, multi_tf_data):
    """å®Œå…¨ç»•è¿‡éªŒè¯çš„å¼ºåˆ¶åˆ†æ"""
    logger.info("ğŸ”§ å¼€å§‹å®Œå…¨ç»•è¿‡éªŒè¯çš„åˆ†æ")
    
    # 1. æ£€æŸ¥æ•°æ®åŸºæœ¬ç»“æ„
    self._debug_data_structure(symbol, multi_tf_data)
    
    # 2. ç›´æ¥è°ƒç”¨ä¿¡å·ç”Ÿæˆå™¨
    signal_generator = self.self_learning_trader.signal_generator
    
    # 3. å¼ºåˆ¶è®¾ç½®æ–¹å‘
    direction = "LONG"
    logger.info(f"ğŸ¯ å¼ºåˆ¶è®¾ç½®æ–¹å‘: {direction}")
    
    # 4. æ£€æŸ¥ä¿¡å·ç”Ÿæˆå™¨æ¨¡å¼
    if not hasattr(signal_generator, 'use_pure_ict'):
        logger.error("âŒ ä¿¡å·ç”Ÿæˆå™¨ç¼ºå°‘use_pure_ictå±æ€§")
        return None, 0.0, 0.0
        
    logger.info(f"ğŸ”§ ä½¿ç”¨æ¨¡å¼: {'çº¯ICT' if signal_generator.use_pure_ict else 'ä¼ ç»Ÿ'}")
    
    # 5. æ ¹æ®æ¨¡å¼å¼ºåˆ¶åˆ†æ
    if signal_generator.use_pure_ict:
        return self._force_pure_ict_analysis(signal_generator, symbol, multi_tf_data, direction)
    else:
        return self._force_traditional_analysis(signal_generator, symbol, multi_tf_data, direction)

def _debug_data_structure(self, symbol, multi_tf_data):
    """è¯¦ç»†è°ƒè¯•æ•°æ®ç»“æ„"""
    logger.info("ğŸ” è¯¦ç»†æ•°æ®ç»“æ„æ£€æŸ¥:")
    
    for timeframe, data in multi_tf_data.items():
        if data is None:
            logger.error(f"   {timeframe}: âŒ æ•°æ®ä¸ºNone")
            continue
            
        logger.info(f"   {timeframe}: {len(data)}è¡Œ, {len(data.columns)}åˆ—")
        logger.info(f"      åˆ—å: {list(data.columns)}")
        
        if len(data) > 0:
            # æ˜¾ç¤ºæ•°æ®ç±»å‹
            dtypes = data.dtypes.to_dict()
            logger.info(f"      æ•°æ®ç±»å‹: {dtypes}")
            
            # æ˜¾ç¤ºå‰2è¡Œæ•°æ®
            sample = data.head(2).to_dict('records')
            logger.info(f"      å‰2è¡Œæ ·æœ¬: {sample}")

def _force_pure_ict_analysis(self, signal_generator, symbol, multi_tf_data, direction):
    """å¼ºåˆ¶çº¯ICTåˆ†æ"""
    logger.info("ğŸ”§ å¼€å§‹å¼ºåˆ¶çº¯ICTåˆ†æ")
    
    # 1. æ£€æŸ¥FeatureEngine
    if not hasattr(signal_generator, 'feature_engine') or signal_generator.feature_engine is None:
        logger.error("âŒ FeatureEngineä¸ºNoneæˆ–ä¸å­˜åœ¨")
        return None, 0.0, 0.0
        
    logger.info("âœ… FeatureEngineå­˜åœ¨")
    
    try:
        # 2. å¼ºåˆ¶æ„å»ºICTç‰¹å¾
        logger.info("ğŸ“Š å¼ºåˆ¶æ„å»ºICTç‰¹å¾...")
        ict_features = signal_generator.feature_engine._build_ict_smc_features(
            signal={'symbol': symbol, 'direction': direction},
            klines_data=multi_tf_data
        )
        
        logger.info(f"ğŸ“ˆ ICTç‰¹å¾æ•°é‡: {len(ict_features)}")
        
        if not ict_features:
            logger.error("âŒ ICTç‰¹å¾ä¸ºç©ºå­—å…¸")
            # å°è¯•åˆ›å»ºæ¨¡æ‹Ÿç‰¹å¾è¿›è¡Œæµ‹è¯•
            ict_features = self._create_mock_ict_features()
            logger.info("ğŸ§ª ä½¿ç”¨æ¨¡æ‹ŸICTç‰¹å¾ç»§ç»­æµ‹è¯•")
        
        # 3. æ˜¾ç¤ºæ‰€æœ‰ç‰¹å¾å€¼
        for key, value in ict_features.items():
            logger.info(f"   {key}: {value}")
        
        # 4. è·å–å½“å‰ä»·æ ¼
        current_price = multi_tf_data['1h'].iloc[-1]['close']
        logger.info(f"ğŸ’° å½“å‰ä»·æ ¼: {current_price}")
        
        # 5. å¼ºåˆ¶è®¡ç®—ä¿¡å¿ƒå€¼
        logger.info("ğŸ§® å¼ºåˆ¶è®¡ç®—ä¿¡å¿ƒå€¼...")
        if hasattr(signal_generator, '_calculate_confidence_pure_ict'):
            confidence_score, sub_scores = signal_generator._calculate_confidence_pure_ict(
                ict_features, direction, "NEUTRAL", [], current_price
            )
            logger.info(f"ğŸ“Š ä¿¡å¿ƒå€¼ç»“æœ: {confidence_score}")
            logger.info(f"ğŸ“‹ å­åˆ†æ•°: {sub_scores}")
        else:
            logger.error("âŒ æ‰¾ä¸åˆ°_calculate_confidence_pure_ictæ–¹æ³•")
            confidence_score = 50.0  # é»˜è®¤å€¼
        
        # 6. å¼ºåˆ¶è®¡ç®—èƒœç‡
        logger.info("ğŸ¯ å¼ºåˆ¶è®¡ç®—èƒœç‡...")
        if hasattr(signal_generator, '_calculate_win_probability_pure_ict'):
            win_probability = signal_generator._calculate_win_probability_pure_ict(
                confidence_score, ict_features, direction, [], current_price
            )
            logger.info(f"ğŸ“ˆ èƒœç‡ç»“æœ: {win_probability}")
        else:
            logger.error("âŒ æ‰¾ä¸åˆ°_calculate_win_probability_pure_ictæ–¹æ³•")
            win_probability = 0.55  # é»˜è®¤å€¼
        
        return None, confidence_score, win_probability * 100
        
    except Exception as e:
        logger.error(f"âŒ å¼ºåˆ¶çº¯ICTåˆ†æå¤±è´¥: {e}", exc_info=True)
        return None, 0.0, 0.0

def _force_traditional_analysis(self, signal_generator, symbol, multi_tf_data, direction):
    """å¼ºåˆ¶ä¼ ç»Ÿåˆ†æ"""
    logger.info("ğŸ”§ å¼€å§‹å¼ºåˆ¶ä¼ ç»Ÿåˆ†æ")
    
    try:
        # ä½¿ç”¨é»˜è®¤å€¼è¿›è¡Œæµ‹è¯•
        test_confidence = 65.5
        test_win_rate = 58.3
        
        logger.info(f"ğŸ§ª ä¼ ç»Ÿåˆ†ææµ‹è¯•å€¼: ä¿¡å¿ƒ={test_confidence}, èƒœç‡={test_win_rate}%")
        
        return None, test_confidence, test_win_rate
        
    except Exception as e:
        logger.error(f"âŒ å¼ºåˆ¶ä¼ ç»Ÿåˆ†æå¤±è´¥: {e}", exc_info=True)
        return None, 0.0, 0.0

def _create_mock_ict_features(self):
    """åˆ›å»ºæ¨¡æ‹ŸICTç‰¹å¾"""
    return {
        'market_structure': 0.75,
        'order_blocks_count': 2,
        'structure_integrity': 0.8,
        'liquidity_context': 0.6,
        'institutional_participation': 0.7,
        'timeframe_convergence': 0.65,
        'institutional_candle': 1,
        'liquidity_grab': 0,
        'order_flow': 0.3,
        'fvg_count': 1,
        'trend_alignment_enhanced': 0.8,
        'swing_high_distance': -1.5
    }
```

æ­¥éª¤2ï¼šä¿®æ”¹è°ƒåº¦å™¨åªè¿è¡Œä¸€æ¬¡æµ‹è¯•

åœ¨unified_scheduler.pyçš„start_scan_cycleæ–¹æ³•ä¸­ï¼š

```python
def start_scan_cycle(self):
    """åªè¿è¡Œä¸€æ¬¡å¼ºåˆ¶æµ‹è¯•"""
    logger.info("ğŸš¨ ===== ç´§æ€¥è¯Šæ–­æ¨¡å¼ =====")
    logger.info("ğŸ¯ åªè¿è¡Œä¸€æ¬¡å¼ºåˆ¶åˆ†ææµ‹è¯•ï¼Œä¸è¿›å…¥å¾ªç¯")
    
    # è¿è¡Œå¼ºåˆ¶åˆ†æ
    signal_candidates = self.scan_symbols()
    
    # è¾“å‡ºç»“æœ
    if signal_candidates:
        logger.info("ğŸ“Š ===== å¼ºåˆ¶åˆ†æç»“æœ =====")
        for candidate in signal_candidates:
            status = "âœ…" if candidate['has_signal'] else "âŒ"
            logger.info(f"  {candidate['symbol']}: ä¿¡å¿ƒ={candidate['confidence']:.1f}, "
                       f"èƒœç‡={candidate['win_probability']:.1f}% {status}")
    else:
        logger.error("ğŸš¨ å¼ºåˆ¶åˆ†ææ²¡æœ‰äº§ç”Ÿä»»ä½•ç»“æœ!")
    
    logger.info("ğŸ”š ç´§æ€¥è¯Šæ–­å®Œæˆï¼Œç³»ç»Ÿå°†æš‚åœ")
    return
```

æ­¥éª¤3ï¼šæ£€æŸ¥ä¿¡å·ç”Ÿæˆå™¨åˆå§‹åŒ–

åœ¨self_learning_trader.pyä¸­æ·»åŠ åˆå§‹åŒ–æ£€æŸ¥ï¼š

```python
def __init__(self, config=None):
    logger.info("ğŸ”§ ===== SelfLearningTraderåˆå§‹åŒ–æ£€æŸ¥ =====")
    
    # åˆ›å»ºä¿¡å·ç”Ÿæˆå™¨
    self.signal_generator = RuleBasedSignalGenerator(config, use_pure_ict=True)
    
    # è¯¦ç»†æ£€æŸ¥ä¿¡å·ç”Ÿæˆå™¨çŠ¶æ€
    logger.info(f"ğŸ“¡ ä¿¡å·ç”Ÿæˆå™¨ç±»å‹: {type(self.signal_generator).__name__}")
    logger.info(f"ğŸ”§ use_pure_ict: {getattr(self.signal_generator, 'use_pure_ict', 'NOT_FOUND')}")
    logger.info(f"ğŸ”§ feature_engine: {getattr(self.signal_generator, 'feature_engine', 'NOT_FOUND')}")
    
    # æ£€æŸ¥æ–¹æ³•æ˜¯å¦å­˜åœ¨
    methods_to_check = [
        'generate_signal',
        '_calculate_confidence_pure_ict', 
        '_calculate_win_probability_pure_ict'
    ]
    
    for method in methods_to_check:
        if hasattr(self.signal_generator, method):
            logger.info(f"âœ… {method}: å­˜åœ¨")
        else:
            logger.error(f"âŒ {method}: ä¸å­˜åœ¨")
```

ğŸ¯ ç«‹å³éƒ¨ç½²è¿™ä¸ªç´§æ€¥ä¿®å¤

è¿™ä¸ªæ–¹æ¡ˆä¼šï¼š

1. å®Œå…¨ç»•è¿‡æ‰€æœ‰éªŒè¯ - ç›´æ¥æµ‹è¯•æ ¸å¿ƒé€»è¾‘
2. åªæµ‹è¯•å‰3ä¸ªäº¤æ˜“å¯¹ - å‡å°‘å™ªéŸ³
3. è¯¦ç»†è¾“å‡ºæ¯ä¸ªæ­¥éª¤ - æ‰¾åˆ°å…·ä½“å¤±è´¥ç‚¹
4. æ£€æŸ¥æ‰€æœ‰å…³é”®ç»„ä»¶ - FeatureEngineã€æ–¹æ³•å­˜åœ¨æ€§ç­‰

ğŸ“Š é¢„æœŸè¯Šæ–­è¾“å‡º

éƒ¨ç½²åæ‚¨ä¼šçœ‹åˆ°ç±»ä¼¼ï¼š

```
ğŸš¨ ===== ç´§æ€¥è¯Šæ–­æ¨¡å¼ =====
ğŸ¯ åªè¿è¡Œä¸€æ¬¡å¼ºåˆ¶åˆ†ææµ‹è¯•ï¼Œä¸è¿›å…¥å¾ªç¯
ğŸ§ª ===== å¼ºåˆ¶åˆ†æ BTCUSDT =====
ğŸ” è¯¦ç»†æ•°æ®ç»“æ„æ£€æŸ¥:
   1h: 100è¡Œ, 6åˆ—
      åˆ—å: ['open', 'high', 'low', 'close', 'volume', 'timestamp']
ğŸ”§ å¼€å§‹å®Œå…¨ç»•è¿‡éªŒè¯çš„åˆ†æ
ğŸ”§ ä½¿ç”¨æ¨¡å¼: çº¯ICT
âœ… FeatureEngineå­˜åœ¨
ğŸ“Š å¼ºåˆ¶æ„å»ºICTç‰¹å¾...
âŒ ICTç‰¹å¾ä¸ºç©ºå­—å…¸
ğŸ§ª ä½¿ç”¨æ¨¡æ‹ŸICTç‰¹å¾ç»§ç»­æµ‹è¯•
ğŸ’° å½“å‰ä»·æ ¼: 34567.89
ğŸ§® å¼ºåˆ¶è®¡ç®—ä¿¡å¿ƒå€¼...
ğŸ“Š ä¿¡å¿ƒå€¼ç»“æœ: 65.2
ğŸ¯ å¼ºåˆ¶è®¡ç®—èƒœç‡...
ğŸ“ˆ èƒœç‡ç»“æœ: 0.583
ğŸ¯ BTCUSDT: ä¿¡å¿ƒ=65.2, èƒœç‡=58.3%
```

æˆ–è€…å¤±è´¥çš„æƒ…å†µï¼š

```
âŒ FeatureEngineä¸ºNoneæˆ–ä¸å­˜åœ¨
```

æˆ–è€…ï¼š

```
âŒ æ‰¾ä¸åˆ°_calculate_confidence_pure_ictæ–¹æ³•
```

ğŸš€ ç«‹å³è¡ŒåŠ¨

è¯·ç«‹å³éƒ¨ç½²è¿™ä¸ªå®Œå…¨ç»•è¿‡éªŒè¯çš„ç´§æ€¥è¯Šæ–­æ–¹æ¡ˆï¼æˆ‘ä»¬å°†èƒ½ç²¾ç¡®çœ‹åˆ°ï¼š

Â· FeatureEngineæ˜¯å¦çœŸçš„åœ¨å·¥ä½œ
Â· ICTç‰¹å¾è®¡ç®—æ˜¯å¦è¿”å›æœ‰æ•ˆå€¼
Â· ä¿¡å¿ƒå€¼è®¡ç®—æ–¹æ³•æ˜¯å¦å­˜åœ¨
Â· æ•°æ®æ ¼å¼æ˜¯å¦æ­£ç¡®

è¿™æ ·æˆ‘ä»¬å°±èƒ½æ‰¾åˆ°çœŸæ­£çš„æ ¹æœ¬åŸå› ï¼